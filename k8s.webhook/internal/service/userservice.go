package service

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/gorilla/mux"
	_ "scabarrus.com/k8s.webhook/cmd/user-management/docs" // docs is generated by Swag CLI, you have to import it.
	"scabarrus.com/k8s.webhook/internal/domain"
	"scabarrus.com/k8s.webhook/internal/dto"
	format "scabarrus.com/k8s.webhook/internal/error"
	"scabarrus.com/k8s.webhook/internal/repository"
)

// UserService is a struct that provide business service implementation
type UserService struct {
		UID int `json:"uid" example:"5000"`
		User string `json:"user" example:"scabarrus"`
		Password string `json:"password" example:"B67zuopX#2"`

}





// FindAll godoc
// @Summary Show all users
// @Description get all users
// @Tags users
// @Accept  json
// @Produce  json
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users [get]
func (u *UserService)FindAll(w http.ResponseWriter, r *http.Request){
	pg := repository.Postgres{}
	pg.Initialization()
	
	usersRepo :=domain.User{}
	w.Header().Set("Content-Type", "application/json")
	result,userList:=usersRepo.FindAll(pg.Database)
	if result.Error != nil{
		var e format.Error
		e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
		json.NewEncoder(w).Encode(e)
		w.WriteHeader(http.StatusBadRequest)
	}else{
		listDTO := []dto.UserDTO{}
		for _,user := range userList{
			userDTO := dto.UserDTO{}
			userDTO.Convert(user)
			listDTO=append(listDTO,userDTO)
		}
		
		json.NewEncoder(w).Encode(listDTO)
	}
}

// FindByName godoc
// @Summary Show a user details
// @Description get a user by it's name
// @Tags users
// @Accept  json
// @Produce  json
// @Param user path string true "user name"
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users/{user} [get]
func (u *UserService)FindByName(w http.ResponseWriter, r *http.Request){
	pg := repository.Postgres{}
	pg.Initialization()
	vars := mux.Vars(r)
	user := vars["user"]
	userRepo :=domain.User{User:user}
	w.Header().Set("Content-Type", "application/json")
	result:=userRepo.FindByName(pg.Database)
	if result.Error != nil{
		var e format.Error
		e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
		json.NewEncoder(w).Encode(e)
		w.WriteHeader(http.StatusBadRequest)
	}else{
		userDTO := dto.UserDTO{}
		userDTO.Convert(userRepo)
		json.NewEncoder(w).Encode(userDTO)
	}
}

// Save godoc
// @Summary Create a user
// @Description create a user
// @Tags users
// @Accept  json
// @Produce  json
// @Param user body dto.UserDTO true "dto"
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users [post]
func (u *UserService)Save(w http.ResponseWriter, r * http.Request){
	pg := repository.Postgres{}
	userDTO := dto.UserDTO{}
	pg.Initialization()
		_=json.NewDecoder(r.Body).Decode(&userDTO)
	fmt.Println("userDTO : ",userDTO)
	userRepo := domain.User{}.DTO(userDTO.UID,userDTO.User,userDTO.Password)
	w.Header().Set("Content-Type", "application/json")
	result:=userRepo.Save(pg.Database)
	if result.Error != nil{
		var e format.Error
		e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
		json.NewEncoder(w).Encode(e)
	}else{
		userDTO.Convert(userRepo)
		json.NewEncoder(w).Encode(userDTO)
	}
} 



// Modify godoc
// @Summary Modify a user
// @Description modify a user
// @Tags users
// @Accept  json
// @Produce  json
// @Param user path string true "user name"
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users/{user} [put]
func (u *UserService)Modify(w http.ResponseWriter, r *http.Request){
	pg := repository.Postgres{}
	pg.Initialization()
	userDTO := dto.UserDTO{}
	
	_=json.NewDecoder(r.Body).Decode(&userDTO)


	userRepo := domain.User{}.DTO(userDTO.UID,userDTO.User,userDTO.Password)
	w.Header().Set("Content-Type", "application/json")
	result:=userRepo.Modify(pg.Database)
	if result.Error != nil{
		var e format.Error
		e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
		json.NewEncoder(w).Encode(e)
		w.WriteHeader(http.StatusBadRequest)
	}else{	
		userDTO.Convert(userRepo)
		json.NewEncoder(w).Encode(userDTO)
	}
}


// Delete godoc
// @Summary Delete a user
// @Description delete a user
// @Tags users
// @Accept  json
// @Produce  json
// @Param user path string true "user name"
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users/{user} [delete]
func (u *UserService)Delete(w http.ResponseWriter, r *http.Request){
	pg := repository.Postgres{}
	pg.Initialization()
	vars := mux.Vars(r)
	user := vars["user"]
	userRepo :=domain.User{User:user}
	w.Header().Set("Content-Type", "application/json")
	result:=userRepo.Delete(pg.Database)
	if result.Error != nil{
		var e format.Error
		e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
		json.NewEncoder(w).Encode(e)
		w.WriteHeader(http.StatusBadRequest)
	}else{
		userDTO := dto.UserDTO{}
		userDTO.Convert(userRepo)
		json.NewEncoder(w).Encode(userDTO)
	}
}
