package service

import (
	"encoding/json"
	"net/http"

	"github.com/gorilla/mux"
	_ "scabarrus.com/k8s.webhook/cmd/user-management/docs" // docs is generated by Swag CLI, you have to import it.
	"scabarrus.com/k8s.webhook/internal/domain"
	"scabarrus.com/k8s.webhook/internal/dto"
	format "scabarrus.com/k8s.webhook/internal/error"
	"scabarrus.com/k8s.webhook/internal/repository"
)

// UserService is a struct that provide business service implementation
type UserService struct {
		UID int `json:"uid" example:"5000"`
		User string `json:"user" example:"scabarrus"`
		Password string `json:"password" example:"B67zuopX#2"`

}





// FindAll godoc
// @Summary Show all users
// @Description get all users
// @Tags users
// @Accept  json
// @Produce  json
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users [get]
func (u *UserService)FindAll(w http.ResponseWriter, r *http.Request){
	pg := repository.Postgres{}
	pg.Initialization()
	
	usersRepo :=domain.User{}
	w.Header().Set("Content-Type", "application/json")
	result,userList:=usersRepo.FindAll(pg.Database)
	if result.Error != nil{
		var e format.Error
		e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
		json.NewEncoder(w).Encode(e)
		w.WriteHeader(http.StatusBadRequest)
	}else{
		listDTO := []dto.UserDTO{}
		for _,user := range userList{
			userDTO := dto.UserDTO{}
			userDTO.Convert(user)
			listDTO=append(listDTO,userDTO)
		}
		
		json.NewEncoder(w).Encode(listDTO)
	}
}

// FindByName godoc
// @Summary Show a user details
// @Description get a user by it's name
// @Tags users
// @Accept  json
// @Produce  json
// @Param user path string true "user name"
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users/{user} [get]
func (u *UserService)FindByName(w http.ResponseWriter, r *http.Request){
	pg := repository.Postgres{}
	pg.Initialization()
	vars := mux.Vars(r)
	user := vars["user"]
	userRepo :=domain.User{User:user}
	w.Header().Set("Content-Type", "application/json")
	result:=userRepo.FindByName(pg.Database)
	if result.Error != nil{
		var e format.Error
		e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
		json.NewEncoder(w).Encode(e)
		w.WriteHeader(http.StatusBadRequest)
	}else{
		userDTO := dto.UserDTO{}
		userDTO.Convert(userRepo)
		json.NewEncoder(w).Encode(userDTO)
	}
}

// Save godoc
// @Summary Create a user
// @Description create a user
// @Tags users
// @Accept  json
// @Produce  json
// @Param user body dto.UserDTO true "dto"
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users [post]
func (u *UserService)Save(w http.ResponseWriter, r * http.Request){
	pg := repository.Postgres{}
	userDTO := dto.UserDTO{}
	pg.Initialization()
	_=json.NewDecoder(r.Body).Decode(&userDTO)

	var e format.Error
	message,details,_ :=e.Unmarshal(&userDTO)
    if message != "" {
		e.FormatError(message,details,r.RequestURI)
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(e)
	}else{
		userRepo := domain.User{}.DTO(userDTO.UID,userDTO.User,userDTO.Password)
		w.Header().Set("Content-Type", "application/json")
		result:=userRepo.Save(pg.Database)
		if result.Error != nil{
			e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
			json.NewEncoder(w).Encode(e)
		}else{
			userDTO.Convert(userRepo)
			json.NewEncoder(w).Encode(userDTO)
		}
	}
} 



// Modify godoc
// @Summary Modify a user
// @Description modify a user
// @Tags users
// @Accept  json
// @Produce  json
// @Param user path string true "user name"
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users/{user} [put]
func (u *UserService)Modify(w http.ResponseWriter, r *http.Request){
	pg := repository.Postgres{}
	pg.Initialization()
	userDTO := dto.UserDTO{}
	
	_=json.NewDecoder(r.Body).Decode(&userDTO)
	var e format.Error
	vars := mux.Vars(r)
	userRepo := domain.User{}.DTO(userDTO.UID,userDTO.User,userDTO.Password)
	w.Header().Set("Content-Type", "application/json")
	user := vars["user"]
	if user != userDTO.User{
			e.FormatError("input Error - ","mismatch between user name in path ("+user+") and body ("+userDTO.User+")",r.RequestURI)
			json.NewEncoder(w).Encode(e)
			w.WriteHeader(http.StatusBadRequest)
	}
	message,details,_ :=e.Unmarshal(&userDTO)
    if message != "" {
		e.FormatError(message,details,r.RequestURI)
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(e)
	}else{
		result:=userRepo.Modify(pg.Database)
		if result.Error != nil{
			e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
			json.NewEncoder(w).Encode(e)
			w.WriteHeader(http.StatusBadRequest)
		}else{
			if result.RowsAffected == 0{
				e.FormatError("Input Error - ","Non editable field are modified!",r.RequestURI)
				json.NewEncoder(w).Encode(e)
				w.WriteHeader(http.StatusBadRequest)
			}else{
				userDTO.Convert(userRepo)
				json.NewEncoder(w).Encode(userDTO)
			}
		}
	}
}


// Delete godoc
// @Summary Delete a user
// @Description delete a user
// @Tags users
// @Accept  json
// @Produce  json
// @Param user path string true "user name"
// @Success 200 {object} dto.UserDTO true "dto"
// @Success 400 {object} format.Error
// @Router /users/{user} [delete]
func (u *UserService)Delete(w http.ResponseWriter, r *http.Request){
	pg := repository.Postgres{}
	pg.Initialization()
	vars := mux.Vars(r)
	user := vars["user"]
	userRepo :=domain.User{User:user}
	w.Header().Set("Content-Type", "application/json")
	result:=userRepo.Delete(pg.Database)
	if result.Error != nil{
		var e format.Error
		e.FormatError("SQL Error - ",result.Error.Error(),r.RequestURI)
		json.NewEncoder(w).Encode(e)
		w.WriteHeader(http.StatusBadRequest)
	}else{
		userDTO := dto.UserDTO{}
		userDTO.Convert(userRepo)
		json.NewEncoder(w).Encode(userDTO)
	}
}
